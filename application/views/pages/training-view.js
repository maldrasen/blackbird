global.TrainingView = (function() {

  let $mainCategories;
  let $partCategories;

  function init() {
    $mainCategories = new Set();
    $partCategories = new Set();

    SexAction.getAllCodes().forEach(code => {
      const action = SexAction.lookup(code);
      $mainCategories.add(action.getMainCategory());
      $partCategories.add(action.getPartCategory());
    });

    $mainCategories = [...$mainCategories].sort();
    $partCategories = [...$partCategories].sort();
  }

  function show() {
    console.log("=== TrainingView.show() Called ===")

    const location = Location.lookup(GameState.getCurrentLocation());

    MainContent.setMainContent("views/training.html");
    MainContent.setBackground(location.getBackground());

    buildStatusPanel();
  }

  function buildStatusPanel() {
    const sideToggles = X.first('#sideToggles');
    const topToggles = X.first('#topToggles');
    const actionList = X.first('#actionList');

    $mainCategories.forEach(name => {
      sideToggles.appendChild(X.createElement(
        `<li class="toggle on"><a data-type="main" data-name="${name}" href="#">${name}</a></li>`));
    });

    $partCategories.forEach(name => {
      topToggles.appendChild(X.createElement(
        `<li class="toggle on"><a data-type="part" data-name="${name}" href="#">${name}</a></li>`));
    });

    // All actions are added to the panel, even actions that will always be hidden. Each round will need to determine
    // which actions should be visible, and enabled. Potentially, this game with have a hundred or more actions and
    // eventually the action list will need to be placed in a scrolling panel.
    SexAction.getAllCodes().forEach(code => {
      const action = SexAction.lookup(code);

      actionList.appendChild(X.createElement(
        `<li class="xhide"><a class="button xdisabled"
            data-code="${action.getCode()}"
            data-main-category="${action.getMainCategory()}"
            data-part-category="${action.getPartCategory()}"
            href="#">${action.getName()}</a></li>`));
    });


    // Name (Status Effects) (Relevant Stats)
    // [clothing]
    // [Stamina Bar] (2000/2000)
    // [Health Bar] (100/100)
    // -- PALAM ----- -------------- -------------- --------------
    // C Ples         V Ples         A Ples         B Ples        // Include pleasure ramps?
    // M Ples         Loyal          Desire         Submission
    // V Wet          A Wet          Shame          Learn         // These attributes are limited to the current scene and start at 0.
    // Pain           Fear           Hostile        Depression    // Which make sense to carry over. The whole convert to gems step is still mysterious.
    // Milk [7000/10000]
    // Sex[   ](0/2) Semen[XX  ](4/9) womb[X   ](3646p)       // Satasfaction Row [number of orgasms] []
    // In Use: [Clit Cap], [Nipple Cap]

    // My attributes:
    // [Control] slow changing, but training is used to increase it, so probably good to have.
    // [Affection/Fear/Respect] - Top level attributes to replace favor and service?
    // [Arousal/Pleasure] important to track. Can be on top rather than tracked on each part.

    // Pleasure bars would work better as a column of body parts.
    // Second column for training values, (loyal/obedience)/desire/submission/(shame/exposure)/(hostile/anger)/(depression/trauma)

    // Obedience / Desire / Submission (Built with light actions, kissing, carressing. More difficult actions possible as Obedience level increases.)
    //   desire => Lust Mark
    //
    // Shame / Anger / Suffering
    //   shame =>
    //   anger => Hate Mark (Hate marks raise all training thresholds. Results in orb/gem loss.)
    //   suffering(depression) = Pain Mark


    // The 'PALAM' bars overflow from the raw 'SOURCE' values generated by the actions.
    // The amount that overflows from the bars are what gets converted into JUEL (the gems)
    // Gems are spent on abilities.

    // Controller will need to maintain a training state, these training values are converted into the 'gems'
  }

  return Object.freeze({
    init,
    show,
  });

})();
