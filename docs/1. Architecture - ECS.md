Project Blackbird will be using a hybrid ECS system for most things. Any data that's going to be persisted in a save file should be within a component. Whatever the current view is will also maintain it's own state, just for convenience.

### Entities
An entity is nothing more than an ID. The `Registry` is used to manage all of the component data associated with an entity ID. To do this, the `Registry` uses two maps. The first maps the entity ID to a list of component types that that entity has. The second map is a map of component types, under each different component type is a map of entity ID to the component data for that component type. 

When an Entity Id is removed from the Registry the associated components are also removed from each component registry. When a component is removed any child entities (entities with a `_parentId` that references the entity being removed) are also removed. Because of this relationship, child components should only be things that can't exist without the parent component. Things like body parts or skills, but not things like equipment. If a character with equipment is removed from the game whatever removes it will need handle removing orphaned entities like equipment itself. 

### Components
The components are simple data objects associated with an Entity Id. The components themselves shouldn't have any complicated business logic, mostly just the CRUD functions for that component. The actual 'programming' of the components belongs to the systems. A few components do have 'wrapper' classes that can be used to add simple calculation functions, though they should be limited to accessing component data, never mutating it. Each component also needs to validate its own data, both on create and update.

### Systems
Systems manipulate the component data. For instance, at the end of the day a sleep system might run. The system would look up every character component, adjust stamina, mana, lust, etc values on all of the associated components. 

##### State Machine
The game loop is handled by the `StateMachine`, which specifies what mode the game is currently in; event, training, combat, dungeon, etc. The `StateMachine` receives command objects from the views, encapsulating the user input for that turn. The StateMachine then determines which systems are run given the current mode. Once the systems all run the game pauses again to wait for the next player input command. 

Most of the time, the systems won't have anything to do. Some are just waiting for a specific command to do something. Some do something every time, like health or stamina regeneration. Because we don't have ticks, most commands should take some defined amount of time. That way systems that do something every hour will know when an hour has passed, though they would need to keep track of the last time they were run. 
